#ifndef CONTRACT_TOOLS_H
#define CONTRACT_TOOLS_H

#include "contract_errors.h"
#include <stdio.h>
#include <string.h>

/**
 * @brief Validates and generates a correct errno-to-message mapping by analyzing the packed error string blob.
 *
 * This function walks through the `error_strings` constant character array, which contains
 * null-terminated error messages in the same order as their corresponding POSIX error codes.
 * It prints a fully initialized, correct version of the `errno_to_msg` lookup table,
 * ensuring that each errno value points to the correct message start offset.
 *
 * The output is intended to be copied back into the source to eliminate manual offset errors
 * and guarantee consistency between the string blob and the pointer array.
 *
 * Example output:
 *     [ 22] = error_strings + 401,  // "Invalid argument"
 *
 * @note This function assumes that the order of strings in `error_strings[]` matches
 *       the expected sequence of errno values defined in `posix_error_t`.
 *
 * @note Design and implementation support from an AI assistant (based on Llama 3).
 *         No license restrictions; contribution is part of the public domain.
 */
void validate_error_strings(void) {
    printf("/*\n");
    printf(" * AUTO-GENERATED errno_to_msg â€” DO NOT EDIT\n");
    printf(" * Generated by walking error_strings blob\n");
    printf(" */\n");

    const char* strings[] = {
        "Success",
        "Operation not permitted",
        "No such file or directory",
        "No such process",
        "Interrupted system call",
        "Input/output error",
        "No such device or address",
        "Argument list too long",
        "Exec format error",
        "Bad file descriptor",
        "No child processes",
        "Resource unavailable, try again",
        "Out of memory",
        "Permission denied",
        "Bad address",
        "Device or resource busy",
        "File exists",
        "Cross-device link",
        "No such device",
        "Not a directory",
        "Is a directory",
        "Invalid argument",
        "Too many files open in system",
        "Too many open files",
        "Inappropriate ioctl for device",
        "Text file busy",
        "File too large",
        "Read-only file system",
        "Too many links",
        "Broken pipe",
        "Numerical argument out of domain",
        "Result too large",
        "Resource deadlock would occur",
        "File name too long",
        "Directory not empty",
        "Too many levels of symbolic links",
        "Identifier removed",
        "Timer expired",
        "Link has been severed",
        "Protocol error",
        "Value too large to be stored in data type",
        "No locks available",
        "Illegal byte sequence",
        "Message too long",
        "Protocol wrong type for socket",
        "Protocol not supported",
        "Operation not supported",
        "Network is down",
        "Network is unreachable",
        "Connection timed out",
        "No route to host",
        "Connection already in progress",
        "Operation in progress",
        "Stale file handle",
        "Operation canceled",
        "Previous owner died",
        "State not recoverable"
    };

    const int errnos[] = {
        0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
        10,  11,  12,  13,  14,  16,  17,  18,  19,  20,
        21,  22,  23,  24,  25,  26,  27,  30,  31,  32,
        33,  34,  35,  36,  39,  40,  43,  62,  67,  71,
        75,  77,  84,  90,  91,  93,  95, 100, 101, 110,
        113, 114, 115, 116, 125, 130, 131
    };

    const int n = 58;  // number of strings

    printf("static const char* const errno_to_msg[132] = {\n");

    const char* p = error_strings;
    int offset = 0;

    for (int i = 0; i < n; i++) {
        // Find next string in blob
        while (p != error_strings + offset) {
            offset++;
            p = error_strings + offset;
        }

        // Compare
        if (strcmp(p, strings[i]) != 0) {
            printf("/* ERROR: Expected \"%s\", found \"%s\" at offset %d */\n",
                   strings[i], p, offset);
        }

        printf("    [%3d] = error_strings + %d,  // \"%s\"\n",
               errnos[i], offset, strings[i]);

        // Advance to next string
        offset += strlen(p) + 1;
        p = error_strings + offset;
    }

    printf("};\n");
}

#endif
